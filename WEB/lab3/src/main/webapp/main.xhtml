<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:h="http://xmlns.jcp.org/jsf/html"
      xmlns:f="http://xmlns.jcp.org/jsf/core"
      xmlns:p="http://primefaces.org/ui"
      xmlns:ui="http://xmlns.jcp.org/jsf/facelets">
<h:head>
    <title>Проверка попадания точки</title>
    <style>
        .form-container { max-width: 800px; margin: 0 auto; padding: 20px; }
        .plot-container { text-align: center; margin: 20px; position: relative; }
        canvas { border: 1px solid #ccc; background: #f9f9f9; cursor: crosshair; }
        .results-container { margin-top: 30px; }
        .nav-link { display: block; text-align: center; margin: 20px; }
        .controls { display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 15px; }
        .control-group { margin-bottom: 10px; width: 100%; }
        .x-options { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 5px; align-items: center; }
        .x-option { display: flex; align-items: center; gap: 4px; }
        .debug-info { 
            background: #f0f0f0; 
            padding: 10px; 
            margin: 10px 0; 
            font-family: monospace; 
            font-size: 0.9em;
        }
        .json-debug {
            margin: 10px 0;
            padding: 10px;
            background: #e8f4ff;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 200px;
            overflow: auto;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .canvas-container {
            position: relative;
            display: inline-block;
            border: 1px solid #ddd;
            padding: 5px;
            background: white;
            margin: 10px auto;
        }
    </style>
</h:head>
<h:body>
    
    <div class="form-container">
        
        <h:form id="mainForm">
            <p:messages id="globalMessages" autoUpdate="true" showDetail="true" />
            <p:remoteCommand name="sendClick" 
                action="#{plotBean.handleCanvasClick}" 
                process="@this"
                update="resultsTable hiddenDataInput debugInfo jsonDebug"
                oncomplete="redrawPlot()" />

            <p:panel header="Параметры точки">
                <div class="controls">
                    <h:panelGroup layout="block" id="xOptionsGroup" styleClass="control-group">
                        <p:outputLabel value="Выберите X (целое от -5 до 1):" />
                        <div class="x-options">
                            <ui:repeat value="#{plotBean.XOptions}" var="opt">
                                <div class="x-option">
                                    <p:selectBooleanCheckbox value="#{opt.selected}" />
                                    <span style="margin-left:4px">#{opt.value}</span>
                                </div>
                            </ui:repeat>
                        </div>
                        <p:message for="xOptionsGroup" display="icon" />
                    </h:panelGroup>

                    <div class="control-group">
                        <p:outputLabel for="y" value="Координата Y:"/>
                        <p:inputText id="y" value="#{plotBean.y}" 
                                     converter="bigDecimalConverter" 
                                     required="true">
                            
                        </p:inputText>
                        <p:message for="y" display="icon"/>
                    </div>
                    
                    <div class="control-group">
                        <p:outputLabel for="r" value="Радиус R:"/>
                        <h:panelGroup>
                            <p:inputText id="r" value="#{plotBean.r}" converter="bigDecimalConverter"
                                        style="width:60px; background:#eee;">
                                <p:ajax event="change" 
                                        listener="#{plotBean.onRChanged}" 
                                        update="globalMessages hiddenDataInput debugInfo jsonDebug" 
                                        oncomplete="redrawPlot()"
                                        process="@this"           
                                        ignoreAutoUpdate="true"  
                                        resetValues="true"/>     
                            </p:inputText>
                            
                            <p:slider for="r" 
                                      widgetVar="rSlider"
                                      display="rSliderDisplay" 
                                      minValue="2" 
                                      maxValue="5" 
                                      step="0.1"
                                      onSlideEnd="handleSlideEnd()"/>
                                      
                            <h:outputText id="rSliderDisplay" value="#{plotBean.r}" style="margin-left:10px"/>
                        </h:panelGroup>
                    </div>
                    
                    <h:outputScript>
                    function handleSlideEnd() {
                        var input = document.querySelector("[id$=':r']");
                        if (input) {
                            input.value = PF('rSlider').getValue();
                            input.dispatchEvent(new Event('change', { bubbles: true }));
                        }
                    }
                    </h:outputScript>
                </div>
                <p:commandButton id="submitBtn" value="Отправить" 
                                 action="#{plotBean.checkHit}" 
                                 update="resultsTable hiddenDataInput debugInfo jsonDebug globalMessages"
                                 oncomplete="redrawPlot()" 
                                 process="@form"
                                 style="margin-top:10px;"/>
               
            </p:panel>
            
            <h:panelGroup id="jsonDebug" layout="block" styleClass="json-debug">
                <strong>Данные для графика (отладка):</strong>
                <h:outputText value="#{plotBean.plotDataJson}" escape="false" />
            </h:panelGroup>
            
            <div class="plot-container">
                <div class="canvas-container">
                    <h:inputHidden id="hiddenDataInput" value="#{plotBean.plotDataJson}" />
                    <canvas id="plotCanvas" width="600" height="600"></canvas>
                </div>
                <h:outputText id="debugInfo" value="Server R: #{plotBean.r}" 
              style="display:block; color:red; margin-top:5px"/>
            </div>
            
            <div class="results-container">
                <p:dataTable id="resultsTable" value="#{resultsBean.allResults}" var="res"
                             paginator="true" rows="10" emptyMessage="Нет результатов">
                    <p:column headerText="X">
                        <h:outputText value="#{res.x}" converter="bigDecimalConverter"/>
                    </p:column>
                    <p:column headerText="Y">
                        <h:outputText value="#{res.y}" converter="bigDecimalConverter"/>
                    </p:column>
                    <p:column headerText="R">
                        <h:outputText value="#{res.r}" converter="bigDecimalConverter"/>
                    </p:column>
                    <p:column headerText="Попадание">
                        <h:outputText value="#{res.hit ? 'Да' : 'Нет'}"/>
                    </p:column>
                    <p:column headerText="Время">
                        <h:outputText value="#{res.timestamp}">
                            <f:convertDateTime pattern="yyyy-MM-dd HH:mm:ss"/>
                        </h:outputText>
                    </p:column>
                </p:dataTable>
            </div>
            
            <div class="nav-link">
                <h:link outcome="index" value="Вернуться на главную">
                    <f:param name="faces-redirect" value="true"/>
                </h:link>
            </div>
        </h:form>
    </div>

    <script>
    //<![CDATA[
    let plotData = { r: 2.0, points: [] };

    function redrawPlot() {
        const canvas = document.getElementById('plotCanvas');
        if (!canvas) {
            console.warn('Canvas не найден в redrawPlot');
            setTimeout(redrawPlot, 100); 
            return;
        }
        
        const hiddenInput = document.getElementById('mainForm:hiddenDataInput');
        if (hiddenInput && hiddenInput.value) {
            try {
                plotData = JSON.parse(hiddenInput.value);
                console.log('Данные для отрисовки:', plotData);
            } catch (e) {
                console.error('Ошибка парсинга данных графика', e);
                plotData = { r: 2.0, points: [] };
            }
        }

        const ctx = canvas.getContext('2d');
        const w = canvas.width, h = canvas.height;
        const cx = w / 2, cy = h / 2;
        const MAX_R = 5.0;
        const scale = Math.min(w, h) / (2 * MAX_R);

        ctx.clearRect(0, 0, w, h);
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, w, h);

        drawAxes(ctx, w, h, cx, cy, scale, MAX_R);
        drawArea(ctx, cx, cy, scale, plotData.r || 2.0);
        drawPoints(ctx, cx, cy, scale, plotData.points || []);
    }

    function drawAxes(ctx, w, h, cx, cy, scale, maxR) {
        ctx.strokeStyle = '#000'; 
        ctx.lineWidth = 1;
        
        ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(w, cy); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, h); ctx.stroke();

        ctx.fillStyle = '#000'; 
        ctx.font = '12px Arial';
        
        for (let x = -Math.ceil(maxR); x <= Math.ceil(maxR); x++) {
            const px = cx + x * scale;
            if (px >= 0 && px <= w) {
                ctx.beginPath(); ctx.moveTo(px, cy-3); ctx.lineTo(px, cy+3); ctx.stroke();
                ctx.fillText(x.toString(), px - 5, cy + 18);
            }
        }
        
        for (let y = -Math.ceil(maxR); y <= Math.ceil(maxR); y++) {
            const py = cy - y * scale;
            if (py >= 0 && py <= h) {
                ctx.beginPath(); ctx.moveTo(cx-3, py); ctx.lineTo(cx+3, py); ctx.stroke();
                ctx.fillText(y.toString(), cx - 20, py + 4);
            }
        }
        
        ctx.fillText('X', w - 10, cy - 5);
        ctx.fillText('Y', cx + 10, 15);
    }

    function drawArea(ctx, cx, cy, scale, r) {
        // 2-я четверть
        ctx.fillStyle = 'rgba(0,0,255,0.2)';
        ctx.beginPath();
        ctx.arc(cx, cy, (r/2) * scale, Math.PI, 1.5 * Math.PI, false);
        ctx.lineTo(cx, cy);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = 'rgba(0,0,255,0.6)';
        ctx.stroke();

        // 3-я четверть
        ctx.fillStyle = 'rgba(0,255,0,0.2)';
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx - r * scale, cy);
        ctx.lineTo(cx, cy + r * scale);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = 'rgba(0,255,0,0.6)';
        ctx.stroke();

        // 4-я четверть
        ctx.fillStyle = 'rgba(255,0,0,0.2)';
        ctx.beginPath();
        ctx.rect(cx, cy, r * scale, r * scale);
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,0,0,0.6)';
        ctx.stroke();
    }

    function drawPoints(ctx, cx, cy, scale, points) {
        points.forEach(p => {
            const xPx = cx + p.x * scale;
            const yPx = cy - p.y * scale;
            
            ctx.beginPath();
            ctx.arc(xPx, yPx, 5, 0, 2 * Math.PI);
            ctx.fillStyle = p.hit ? 'rgba(0, 150, 0, 0.9)' : 'rgba(200, 0, 0, 0.9)';
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.fillStyle = '#000';
            ctx.font = '10px Arial';
            ctx.fillText(`(${p.x.toFixed(2)}, ${p.y.toFixed(2)})`, xPx + 8, yPx - 8);
        });
    }

    function handleCanvasClick(event) {
        console.log('Обработка клика по canvas');
        const canvas = document.getElementById('plotCanvas');
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        const clientX = event.clientX - rect.left;
        const clientY = event.clientY - rect.top;

        const rawX = clientX * scaleX - canvas.width / 2;
        const rawY = canvas.height / 2 - clientY * scaleY;

        const rInput = document.getElementById('mainForm:r');
        let currentR = 2.0;
        if (rInput && rInput.value) {
            const parsedR = parseFloat(rInput.value.replace(',', '.'));
            if (!isNaN(parsedR)) {
                currentR = parsedR;
            }
        }

        const MAX_R = 5.0;
        const scale = Math.min(canvas.width, canvas.height) / (2 * MAX_R);
        let x = rawX / scale;
        let y = rawY / scale;

        x = Math.round(x * 100) / 100;
        y = Math.round(y * 100) / 100;

        console.log('Клик по графику:', {x, y, r: currentR});
        
        if (typeof sendClick === 'function') {
            sendClick([
                { name: 'x', value: x },
                { name: 'y', value: y },
                { name: 'r', value: currentR }
            ]);
        }
    }

    document.addEventListener('DOMContentLoaded', function() {
        const canvas = document.getElementById('plotCanvas');
        if (canvas) {
            canvas.addEventListener('click', handleCanvasClick);
            setTimeout(redrawPlot, 300);
        } else {
            console.error('Canvas не найден');
        }
        
        $(document).on('pfAjaxComplete', function() {
            redrawPlot();
        });
    });

    if (typeof PrimeFaces !== 'undefined') {
        PrimeFaces.ajax.Queue.prototype.success = function(args) {
            const originalSuccess = this.success;
            return function(data, textStatus, jqXHR) {
                originalSuccess.call(this, data, textStatus, jqXHR);
                setTimeout(redrawPlot, 100);
            };
        };
    }
    //]]>
    </script>
</h:body>
</html>